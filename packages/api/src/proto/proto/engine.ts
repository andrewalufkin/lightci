// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: proto/engine.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  ClientWritableStream,
  handleClientStreamingCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "lightci";

export enum StepStatus {
  STEP_STATUS_UNSPECIFIED = 0,
  STEP_STATUS_PENDING = 1,
  STEP_STATUS_RUNNING = 2,
  STEP_STATUS_SUCCESS = 3,
  STEP_STATUS_FAILED = 4,
  STEP_STATUS_SKIPPED = 5,
  STEP_STATUS_TIMED_OUT = 6,
  UNRECOGNIZED = -1,
}

export function stepStatusFromJSON(object: any): StepStatus {
  switch (object) {
    case 0:
    case "STEP_STATUS_UNSPECIFIED":
      return StepStatus.STEP_STATUS_UNSPECIFIED;
    case 1:
    case "STEP_STATUS_PENDING":
      return StepStatus.STEP_STATUS_PENDING;
    case 2:
    case "STEP_STATUS_RUNNING":
      return StepStatus.STEP_STATUS_RUNNING;
    case 3:
    case "STEP_STATUS_SUCCESS":
      return StepStatus.STEP_STATUS_SUCCESS;
    case 4:
    case "STEP_STATUS_FAILED":
      return StepStatus.STEP_STATUS_FAILED;
    case 5:
    case "STEP_STATUS_SKIPPED":
      return StepStatus.STEP_STATUS_SKIPPED;
    case 6:
    case "STEP_STATUS_TIMED_OUT":
      return StepStatus.STEP_STATUS_TIMED_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StepStatus.UNRECOGNIZED;
  }
}

export function stepStatusToJSON(object: StepStatus): string {
  switch (object) {
    case StepStatus.STEP_STATUS_UNSPECIFIED:
      return "STEP_STATUS_UNSPECIFIED";
    case StepStatus.STEP_STATUS_PENDING:
      return "STEP_STATUS_PENDING";
    case StepStatus.STEP_STATUS_RUNNING:
      return "STEP_STATUS_RUNNING";
    case StepStatus.STEP_STATUS_SUCCESS:
      return "STEP_STATUS_SUCCESS";
    case StepStatus.STEP_STATUS_FAILED:
      return "STEP_STATUS_FAILED";
    case StepStatus.STEP_STATUS_SKIPPED:
      return "STEP_STATUS_SKIPPED";
    case StepStatus.STEP_STATUS_TIMED_OUT:
      return "STEP_STATUS_TIMED_OUT";
    case StepStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PipelineStatus {
  PIPELINE_STATUS_UNSPECIFIED = 0,
  PIPELINE_STATUS_PENDING = 1,
  PIPELINE_STATUS_RUNNING = 2,
  PIPELINE_STATUS_COMPLETED = 3,
  PIPELINE_STATUS_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function pipelineStatusFromJSON(object: any): PipelineStatus {
  switch (object) {
    case 0:
    case "PIPELINE_STATUS_UNSPECIFIED":
      return PipelineStatus.PIPELINE_STATUS_UNSPECIFIED;
    case 1:
    case "PIPELINE_STATUS_PENDING":
      return PipelineStatus.PIPELINE_STATUS_PENDING;
    case 2:
    case "PIPELINE_STATUS_RUNNING":
      return PipelineStatus.PIPELINE_STATUS_RUNNING;
    case 3:
    case "PIPELINE_STATUS_COMPLETED":
      return PipelineStatus.PIPELINE_STATUS_COMPLETED;
    case 4:
    case "PIPELINE_STATUS_FAILED":
      return PipelineStatus.PIPELINE_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PipelineStatus.UNRECOGNIZED;
  }
}

export function pipelineStatusToJSON(object: PipelineStatus): string {
  switch (object) {
    case PipelineStatus.PIPELINE_STATUS_UNSPECIFIED:
      return "PIPELINE_STATUS_UNSPECIFIED";
    case PipelineStatus.PIPELINE_STATUS_PENDING:
      return "PIPELINE_STATUS_PENDING";
    case PipelineStatus.PIPELINE_STATUS_RUNNING:
      return "PIPELINE_STATUS_RUNNING";
    case PipelineStatus.PIPELINE_STATUS_COMPLETED:
      return "PIPELINE_STATUS_COMPLETED";
    case PipelineStatus.PIPELINE_STATUS_FAILED:
      return "PIPELINE_STATUS_FAILED";
    case PipelineStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BuildStatus {
  BUILD_STATUS_UNSPECIFIED = 0,
  BUILD_STATUS_PENDING = 1,
  BUILD_STATUS_RUNNING = 2,
  BUILD_STATUS_SUCCESS = 3,
  BUILD_STATUS_FAILED = 4,
  BUILD_STATUS_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function buildStatusFromJSON(object: any): BuildStatus {
  switch (object) {
    case 0:
    case "BUILD_STATUS_UNSPECIFIED":
      return BuildStatus.BUILD_STATUS_UNSPECIFIED;
    case 1:
    case "BUILD_STATUS_PENDING":
      return BuildStatus.BUILD_STATUS_PENDING;
    case 2:
    case "BUILD_STATUS_RUNNING":
      return BuildStatus.BUILD_STATUS_RUNNING;
    case 3:
    case "BUILD_STATUS_SUCCESS":
      return BuildStatus.BUILD_STATUS_SUCCESS;
    case 4:
    case "BUILD_STATUS_FAILED":
      return BuildStatus.BUILD_STATUS_FAILED;
    case 5:
    case "BUILD_STATUS_CANCELLED":
      return BuildStatus.BUILD_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildStatus.UNRECOGNIZED;
  }
}

export function buildStatusToJSON(object: BuildStatus): string {
  switch (object) {
    case BuildStatus.BUILD_STATUS_UNSPECIFIED:
      return "BUILD_STATUS_UNSPECIFIED";
    case BuildStatus.BUILD_STATUS_PENDING:
      return "BUILD_STATUS_PENDING";
    case BuildStatus.BUILD_STATUS_RUNNING:
      return "BUILD_STATUS_RUNNING";
    case BuildStatus.BUILD_STATUS_SUCCESS:
      return "BUILD_STATUS_SUCCESS";
    case BuildStatus.BUILD_STATUS_FAILED:
      return "BUILD_STATUS_FAILED";
    case BuildStatus.BUILD_STATUS_CANCELLED:
      return "BUILD_STATUS_CANCELLED";
    case BuildStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Empty {
}

export interface Pipeline {
  id: string;
  name: string;
  repository: string;
  workspaceId: string;
  description: string;
  defaultBranch: string;
  status: PipelineStatus;
  steps: Step[];
  createdAt: string;
  updatedAt: string;
}

export interface Step {
  id: string;
  name: string;
  command: string;
  timeoutSeconds: number;
  environment: { [key: string]: string };
  dependencies: string[];
  status: StepStatus;
}

export interface Step_EnvironmentEntry {
  key: string;
  value: string;
}

export interface CreateStepRequest {
  /** Optional field */
  id?: string | undefined;
  name: string;
  command: string;
  timeoutSeconds: number;
  environment: { [key: string]: string };
  dependencies: string[];
}

export interface CreateStepRequest_EnvironmentEntry {
  key: string;
  value: string;
}

export interface Build {
  id: string;
  pipelineId: string;
  branch: string;
  commit: string;
  status: BuildStatus;
  startedAt: string;
  completedAt: string;
  parameters: { [key: string]: string };
}

export interface Build_ParametersEntry {
  key: string;
  value: string;
}

export interface Artifact {
  id: string;
  buildId: string;
  name: string;
  path: string;
  size: number;
  contentType: string;
  metadata: { [key: string]: string };
}

export interface Artifact_MetadataEntry {
  key: string;
  value: string;
}

export interface CreatePipelineRequest {
  name: string;
  repository: string;
  workspaceId: string;
  description: string;
  defaultBranch: string;
  /** Use CreateStepRequest instead of Step */
  steps: CreateStepRequest[];
}

export interface GetPipelineRequest {
  id: string;
}

export interface UpdatePipelineRequest {
  id: string;
  name: string;
  repository: string;
  description: string;
  defaultBranch: string;
  steps: Step[];
}

export interface DeletePipelineRequest {
  id: string;
}

export interface ListPipelinesRequest {
  page: number;
  limit: number;
  filter: string;
  sort: string;
}

export interface ListPipelinesResponse {
  items: Pipeline[];
  total: number;
  page: number;
  limit: number;
}

export interface TriggerBuildRequest {
  pipelineId: string;
  branch: string;
  commit: string;
  parameters: { [key: string]: string };
}

export interface TriggerBuildRequest_ParametersEntry {
  key: string;
  value: string;
}

export interface GetBuildRequest {
  id: string;
}

export interface CancelBuildRequest {
  id: string;
}

export interface ListBuildsRequest {
  page: number;
  limit: number;
  pipelineId: string;
  filter: string;
  sort: string;
}

export interface ListBuildsResponse {
  items: Build[];
  total: number;
  page: number;
  limit: number;
}

export interface BuildLog {
  stepId: string;
  content: string;
  timestamp: string;
}

export interface GetBuildLogsRequest {
  buildId: string;
}

export interface BuildLogs {
  logs: BuildLog[];
}

export interface UploadArtifactRequest {
  metadata?: ArtifactMetadata | undefined;
  chunk?: Buffer | undefined;
}

export interface ArtifactMetadata {
  buildId: string;
  name: string;
  contentType: string;
  metadata: { [key: string]: string };
}

export interface ArtifactMetadata_MetadataEntry {
  key: string;
  value: string;
}

export interface DownloadArtifactRequest {
  id: string;
}

export interface DownloadArtifactResponse {
  chunk: Buffer;
}

export interface ListArtifactsRequest {
  buildId: string;
}

export interface ListArtifactsResponse {
  items: Artifact[];
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBasePipeline(): Pipeline {
  return {
    id: "",
    name: "",
    repository: "",
    workspaceId: "",
    description: "",
    defaultBranch: "",
    status: 0,
    steps: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const Pipeline = {
  encode(message: Pipeline, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.repository !== "") {
      writer.uint32(26).string(message.repository);
    }
    if (message.workspaceId !== "") {
      writer.uint32(34).string(message.workspaceId);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.defaultBranch !== "") {
      writer.uint32(50).string(message.defaultBranch);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pipeline {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipeline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workspaceId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.defaultBranch = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pipeline {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      workspaceId: isSet(object.workspaceId) ? globalThis.String(object.workspaceId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      defaultBranch: isSet(object.defaultBranch) ? globalThis.String(object.defaultBranch) : "",
      status: isSet(object.status) ? pipelineStatusFromJSON(object.status) : 0,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Pipeline): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.workspaceId !== "") {
      obj.workspaceId = message.workspaceId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.defaultBranch !== "") {
      obj.defaultBranch = message.defaultBranch;
    }
    if (message.status !== 0) {
      obj.status = pipelineStatusToJSON(message.status);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Step.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pipeline>, I>>(base?: I): Pipeline {
    return Pipeline.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pipeline>, I>>(object: I): Pipeline {
    const message = createBasePipeline();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.repository = object.repository ?? "";
    message.workspaceId = object.workspaceId ?? "";
    message.description = object.description ?? "";
    message.defaultBranch = object.defaultBranch ?? "";
    message.status = object.status ?? 0;
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseStep(): Step {
  return { id: "", name: "", command: "", timeoutSeconds: 0, environment: {}, dependencies: [], status: 0 };
}

export const Step = {
  encode(message: Step, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.command !== "") {
      writer.uint32(26).string(message.command);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(32).uint32(message.timeoutSeconds);
    }
    Object.entries(message.environment).forEach(([key, value]) => {
      Step_EnvironmentEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    for (const v of message.dependencies) {
      writer.uint32(50).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Step {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.command = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeoutSeconds = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Step_EnvironmentEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.environment[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dependencies.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Step {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      environment: isObject(object.environment)
        ? Object.entries(object.environment).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? stepStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: Step): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.environment) {
      const entries = Object.entries(message.environment);
      if (entries.length > 0) {
        obj.environment = {};
        entries.forEach(([k, v]) => {
          obj.environment[k] = v;
        });
      }
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies;
    }
    if (message.status !== 0) {
      obj.status = stepStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Step>, I>>(base?: I): Step {
    return Step.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Step>, I>>(object: I): Step {
    const message = createBaseStep();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.command = object.command ?? "";
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.environment = Object.entries(object.environment ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.dependencies = object.dependencies?.map((e) => e) || [];
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseStep_EnvironmentEntry(): Step_EnvironmentEntry {
  return { key: "", value: "" };
}

export const Step_EnvironmentEntry = {
  encode(message: Step_EnvironmentEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Step_EnvironmentEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep_EnvironmentEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Step_EnvironmentEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Step_EnvironmentEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Step_EnvironmentEntry>, I>>(base?: I): Step_EnvironmentEntry {
    return Step_EnvironmentEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Step_EnvironmentEntry>, I>>(object: I): Step_EnvironmentEntry {
    const message = createBaseStep_EnvironmentEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateStepRequest(): CreateStepRequest {
  return { id: undefined, name: "", command: "", timeoutSeconds: 0, environment: {}, dependencies: [] };
}

export const CreateStepRequest = {
  encode(message: CreateStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.command !== "") {
      writer.uint32(26).string(message.command);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(32).uint32(message.timeoutSeconds);
    }
    Object.entries(message.environment).forEach(([key, value]) => {
      CreateStepRequest_EnvironmentEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    for (const v of message.dependencies) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.command = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeoutSeconds = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = CreateStepRequest_EnvironmentEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.environment[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dependencies.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStepRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      environment: isObject(object.environment)
        ? Object.entries(object.environment).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateStepRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.environment) {
      const entries = Object.entries(message.environment);
      if (entries.length > 0) {
        obj.environment = {};
        entries.forEach(([k, v]) => {
          obj.environment[k] = v;
        });
      }
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStepRequest>, I>>(base?: I): CreateStepRequest {
    return CreateStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStepRequest>, I>>(object: I): CreateStepRequest {
    const message = createBaseCreateStepRequest();
    message.id = object.id ?? undefined;
    message.name = object.name ?? "";
    message.command = object.command ?? "";
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.environment = Object.entries(object.environment ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.dependencies = object.dependencies?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateStepRequest_EnvironmentEntry(): CreateStepRequest_EnvironmentEntry {
  return { key: "", value: "" };
}

export const CreateStepRequest_EnvironmentEntry = {
  encode(message: CreateStepRequest_EnvironmentEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStepRequest_EnvironmentEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStepRequest_EnvironmentEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStepRequest_EnvironmentEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStepRequest_EnvironmentEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStepRequest_EnvironmentEntry>, I>>(
    base?: I,
  ): CreateStepRequest_EnvironmentEntry {
    return CreateStepRequest_EnvironmentEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStepRequest_EnvironmentEntry>, I>>(
    object: I,
  ): CreateStepRequest_EnvironmentEntry {
    const message = createBaseCreateStepRequest_EnvironmentEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBuild(): Build {
  return { id: "", pipelineId: "", branch: "", commit: "", status: 0, startedAt: "", completedAt: "", parameters: {} };
}

export const Build = {
  encode(message: Build, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.branch !== "") {
      writer.uint32(26).string(message.branch);
    }
    if (message.commit !== "") {
      writer.uint32(34).string(message.commit);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.startedAt !== "") {
      writer.uint32(50).string(message.startedAt);
    }
    if (message.completedAt !== "") {
      writer.uint32(58).string(message.completedAt);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      Build_ParametersEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Build {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuild();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.commit = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.completedAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Build_ParametersEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.parameters[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Build {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      commit: isSet(object.commit) ? globalThis.String(object.commit) : "",
      status: isSet(object.status) ? buildStatusFromJSON(object.status) : 0,
      startedAt: isSet(object.startedAt) ? globalThis.String(object.startedAt) : "",
      completedAt: isSet(object.completedAt) ? globalThis.String(object.completedAt) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Build): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.commit !== "") {
      obj.commit = message.commit;
    }
    if (message.status !== 0) {
      obj.status = buildStatusToJSON(message.status);
    }
    if (message.startedAt !== "") {
      obj.startedAt = message.startedAt;
    }
    if (message.completedAt !== "") {
      obj.completedAt = message.completedAt;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Build>, I>>(base?: I): Build {
    return Build.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Build>, I>>(object: I): Build {
    const message = createBaseBuild();
    message.id = object.id ?? "";
    message.pipelineId = object.pipelineId ?? "";
    message.branch = object.branch ?? "";
    message.commit = object.commit ?? "";
    message.status = object.status ?? 0;
    message.startedAt = object.startedAt ?? "";
    message.completedAt = object.completedAt ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBuild_ParametersEntry(): Build_ParametersEntry {
  return { key: "", value: "" };
}

export const Build_ParametersEntry = {
  encode(message: Build_ParametersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Build_ParametersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuild_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Build_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Build_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Build_ParametersEntry>, I>>(base?: I): Build_ParametersEntry {
    return Build_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Build_ParametersEntry>, I>>(object: I): Build_ParametersEntry {
    const message = createBaseBuild_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseArtifact(): Artifact {
  return { id: "", buildId: "", name: "", path: "", size: 0, contentType: "", metadata: {} };
}

export const Artifact = {
  encode(message: Artifact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.buildId !== "") {
      writer.uint32(18).string(message.buildId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.size !== 0) {
      writer.uint32(40).uint64(message.size);
    }
    if (message.contentType !== "") {
      writer.uint32(50).string(message.contentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Artifact_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Artifact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buildId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.size = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Artifact_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artifact {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Artifact): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.buildId !== "") {
      obj.buildId = message.buildId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artifact>, I>>(base?: I): Artifact {
    return Artifact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artifact>, I>>(object: I): Artifact {
    const message = createBaseArtifact();
    message.id = object.id ?? "";
    message.buildId = object.buildId ?? "";
    message.name = object.name ?? "";
    message.path = object.path ?? "";
    message.size = object.size ?? 0;
    message.contentType = object.contentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseArtifact_MetadataEntry(): Artifact_MetadataEntry {
  return { key: "", value: "" };
}

export const Artifact_MetadataEntry = {
  encode(message: Artifact_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Artifact_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artifact_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Artifact_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artifact_MetadataEntry>, I>>(base?: I): Artifact_MetadataEntry {
    return Artifact_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artifact_MetadataEntry>, I>>(object: I): Artifact_MetadataEntry {
    const message = createBaseArtifact_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreatePipelineRequest(): CreatePipelineRequest {
  return { name: "", repository: "", workspaceId: "", description: "", defaultBranch: "", steps: [] };
}

export const CreatePipelineRequest = {
  encode(message: CreatePipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.repository !== "") {
      writer.uint32(18).string(message.repository);
    }
    if (message.workspaceId !== "") {
      writer.uint32(26).string(message.workspaceId);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.defaultBranch !== "") {
      writer.uint32(42).string(message.defaultBranch);
    }
    for (const v of message.steps) {
      CreateStepRequest.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePipelineRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workspaceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultBranch = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.steps.push(CreateStepRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePipelineRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      workspaceId: isSet(object.workspaceId) ? globalThis.String(object.workspaceId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      defaultBranch: isSet(object.defaultBranch) ? globalThis.String(object.defaultBranch) : "",
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => CreateStepRequest.fromJSON(e)) : [],
    };
  },

  toJSON(message: CreatePipelineRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.workspaceId !== "") {
      obj.workspaceId = message.workspaceId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.defaultBranch !== "") {
      obj.defaultBranch = message.defaultBranch;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => CreateStepRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePipelineRequest>, I>>(base?: I): CreatePipelineRequest {
    return CreatePipelineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePipelineRequest>, I>>(object: I): CreatePipelineRequest {
    const message = createBaseCreatePipelineRequest();
    message.name = object.name ?? "";
    message.repository = object.repository ?? "";
    message.workspaceId = object.workspaceId ?? "";
    message.description = object.description ?? "";
    message.defaultBranch = object.defaultBranch ?? "";
    message.steps = object.steps?.map((e) => CreateStepRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPipelineRequest(): GetPipelineRequest {
  return { id: "" };
}

export const GetPipelineRequest = {
  encode(message: GetPipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPipelineRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPipelineRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetPipelineRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPipelineRequest>, I>>(base?: I): GetPipelineRequest {
    return GetPipelineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPipelineRequest>, I>>(object: I): GetPipelineRequest {
    const message = createBaseGetPipelineRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdatePipelineRequest(): UpdatePipelineRequest {
  return { id: "", name: "", repository: "", description: "", defaultBranch: "", steps: [] };
}

export const UpdatePipelineRequest = {
  encode(message: UpdatePipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.repository !== "") {
      writer.uint32(26).string(message.repository);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.defaultBranch !== "") {
      writer.uint32(42).string(message.defaultBranch);
    }
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePipelineRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultBranch = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePipelineRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      defaultBranch: isSet(object.defaultBranch) ? globalThis.String(object.defaultBranch) : "",
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdatePipelineRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.defaultBranch !== "") {
      obj.defaultBranch = message.defaultBranch;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Step.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePipelineRequest>, I>>(base?: I): UpdatePipelineRequest {
    return UpdatePipelineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePipelineRequest>, I>>(object: I): UpdatePipelineRequest {
    const message = createBaseUpdatePipelineRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.repository = object.repository ?? "";
    message.description = object.description ?? "";
    message.defaultBranch = object.defaultBranch ?? "";
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeletePipelineRequest(): DeletePipelineRequest {
  return { id: "" };
}

export const DeletePipelineRequest = {
  encode(message: DeletePipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeletePipelineRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePipelineRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeletePipelineRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePipelineRequest>, I>>(base?: I): DeletePipelineRequest {
    return DeletePipelineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePipelineRequest>, I>>(object: I): DeletePipelineRequest {
    const message = createBaseDeletePipelineRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListPipelinesRequest(): ListPipelinesRequest {
  return { page: 0, limit: 0, filter: "", sort: "" };
}

export const ListPipelinesRequest = {
  encode(message: ListPipelinesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.page !== 0) {
      writer.uint32(8).uint32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint32(message.limit);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.sort !== "") {
      writer.uint32(34).string(message.sort);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListPipelinesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sort = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelinesRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      sort: isSet(object.sort) ? globalThis.String(object.sort) : "",
    };
  },

  toJSON(message: ListPipelinesRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelinesRequest>, I>>(base?: I): ListPipelinesRequest {
    return ListPipelinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelinesRequest>, I>>(object: I): ListPipelinesRequest {
    const message = createBaseListPipelinesRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.filter = object.filter ?? "";
    message.sort = object.sort ?? "";
    return message;
  },
};

function createBaseListPipelinesResponse(): ListPipelinesResponse {
  return { items: [], total: 0, page: 0, limit: 0 };
}

export const ListPipelinesResponse = {
  encode(message: ListPipelinesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      Pipeline.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).uint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListPipelinesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelinesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Pipeline.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelinesResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Pipeline.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListPipelinesResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Pipeline.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelinesResponse>, I>>(base?: I): ListPipelinesResponse {
    return ListPipelinesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelinesResponse>, I>>(object: I): ListPipelinesResponse {
    const message = createBaseListPipelinesResponse();
    message.items = object.items?.map((e) => Pipeline.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseTriggerBuildRequest(): TriggerBuildRequest {
  return { pipelineId: "", branch: "", commit: "", parameters: {} };
}

export const TriggerBuildRequest = {
  encode(message: TriggerBuildRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pipelineId !== "") {
      writer.uint32(10).string(message.pipelineId);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.commit !== "") {
      writer.uint32(26).string(message.commit);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      TriggerBuildRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TriggerBuildRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerBuildRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.commit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = TriggerBuildRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerBuildRequest {
    return {
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      commit: isSet(object.commit) ? globalThis.String(object.commit) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TriggerBuildRequest): unknown {
    const obj: any = {};
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.commit !== "") {
      obj.commit = message.commit;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TriggerBuildRequest>, I>>(base?: I): TriggerBuildRequest {
    return TriggerBuildRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TriggerBuildRequest>, I>>(object: I): TriggerBuildRequest {
    const message = createBaseTriggerBuildRequest();
    message.pipelineId = object.pipelineId ?? "";
    message.branch = object.branch ?? "";
    message.commit = object.commit ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTriggerBuildRequest_ParametersEntry(): TriggerBuildRequest_ParametersEntry {
  return { key: "", value: "" };
}

export const TriggerBuildRequest_ParametersEntry = {
  encode(message: TriggerBuildRequest_ParametersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TriggerBuildRequest_ParametersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerBuildRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerBuildRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TriggerBuildRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TriggerBuildRequest_ParametersEntry>, I>>(
    base?: I,
  ): TriggerBuildRequest_ParametersEntry {
    return TriggerBuildRequest_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TriggerBuildRequest_ParametersEntry>, I>>(
    object: I,
  ): TriggerBuildRequest_ParametersEntry {
    const message = createBaseTriggerBuildRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetBuildRequest(): GetBuildRequest {
  return { id: "" };
}

export const GetBuildRequest = {
  encode(message: GetBuildRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBuildRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBuildRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBuildRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetBuildRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBuildRequest>, I>>(base?: I): GetBuildRequest {
    return GetBuildRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBuildRequest>, I>>(object: I): GetBuildRequest {
    const message = createBaseGetBuildRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCancelBuildRequest(): CancelBuildRequest {
  return { id: "" };
}

export const CancelBuildRequest = {
  encode(message: CancelBuildRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelBuildRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelBuildRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelBuildRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: CancelBuildRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelBuildRequest>, I>>(base?: I): CancelBuildRequest {
    return CancelBuildRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelBuildRequest>, I>>(object: I): CancelBuildRequest {
    const message = createBaseCancelBuildRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListBuildsRequest(): ListBuildsRequest {
  return { page: 0, limit: 0, pipelineId: "", filter: "", sort: "" };
}

export const ListBuildsRequest = {
  encode(message: ListBuildsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.page !== 0) {
      writer.uint32(8).uint32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint32(message.limit);
    }
    if (message.pipelineId !== "") {
      writer.uint32(26).string(message.pipelineId);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.sort !== "") {
      writer.uint32(42).string(message.sort);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBuildsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBuildsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sort = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBuildsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      sort: isSet(object.sort) ? globalThis.String(object.sort) : "",
    };
  },

  toJSON(message: ListBuildsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBuildsRequest>, I>>(base?: I): ListBuildsRequest {
    return ListBuildsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBuildsRequest>, I>>(object: I): ListBuildsRequest {
    const message = createBaseListBuildsRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.pipelineId = object.pipelineId ?? "";
    message.filter = object.filter ?? "";
    message.sort = object.sort ?? "";
    return message;
  },
};

function createBaseListBuildsResponse(): ListBuildsResponse {
  return { items: [], total: 0, page: 0, limit: 0 };
}

export const ListBuildsResponse = {
  encode(message: ListBuildsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      Build.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).uint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBuildsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBuildsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Build.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBuildsResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Build.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListBuildsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Build.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBuildsResponse>, I>>(base?: I): ListBuildsResponse {
    return ListBuildsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBuildsResponse>, I>>(object: I): ListBuildsResponse {
    const message = createBaseListBuildsResponse();
    message.items = object.items?.map((e) => Build.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseBuildLog(): BuildLog {
  return { stepId: "", content: "", timestamp: "" };
}

export const BuildLog = {
  encode(message: BuildLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepId !== "") {
      writer.uint32(10).string(message.stepId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stepId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildLog {
    return {
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: BuildLog): unknown {
    const obj: any = {};
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildLog>, I>>(base?: I): BuildLog {
    return BuildLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildLog>, I>>(object: I): BuildLog {
    const message = createBaseBuildLog();
    message.stepId = object.stepId ?? "";
    message.content = object.content ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetBuildLogsRequest(): GetBuildLogsRequest {
  return { buildId: "" };
}

export const GetBuildLogsRequest = {
  encode(message: GetBuildLogsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.buildId !== "") {
      writer.uint32(10).string(message.buildId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBuildLogsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBuildLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBuildLogsRequest {
    return { buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "" };
  },

  toJSON(message: GetBuildLogsRequest): unknown {
    const obj: any = {};
    if (message.buildId !== "") {
      obj.buildId = message.buildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBuildLogsRequest>, I>>(base?: I): GetBuildLogsRequest {
    return GetBuildLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBuildLogsRequest>, I>>(object: I): GetBuildLogsRequest {
    const message = createBaseGetBuildLogsRequest();
    message.buildId = object.buildId ?? "";
    return message;
  },
};

function createBaseBuildLogs(): BuildLogs {
  return { logs: [] };
}

export const BuildLogs = {
  encode(message: BuildLogs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.logs) {
      BuildLog.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildLogs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.logs.push(BuildLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildLogs {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => BuildLog.fromJSON(e)) : [] };
  },

  toJSON(message: BuildLogs): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => BuildLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildLogs>, I>>(base?: I): BuildLogs {
    return BuildLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildLogs>, I>>(object: I): BuildLogs {
    const message = createBaseBuildLogs();
    message.logs = object.logs?.map((e) => BuildLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUploadArtifactRequest(): UploadArtifactRequest {
  return { metadata: undefined, chunk: undefined };
}

export const UploadArtifactRequest = {
  encode(message: UploadArtifactRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      ArtifactMetadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    if (message.chunk !== undefined) {
      writer.uint32(18).bytes(message.chunk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UploadArtifactRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadArtifactRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = ArtifactMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chunk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadArtifactRequest {
    return {
      metadata: isSet(object.metadata) ? ArtifactMetadata.fromJSON(object.metadata) : undefined,
      chunk: isSet(object.chunk) ? Buffer.from(bytesFromBase64(object.chunk)) : undefined,
    };
  },

  toJSON(message: UploadArtifactRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = ArtifactMetadata.toJSON(message.metadata);
    }
    if (message.chunk !== undefined) {
      obj.chunk = base64FromBytes(message.chunk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadArtifactRequest>, I>>(base?: I): UploadArtifactRequest {
    return UploadArtifactRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadArtifactRequest>, I>>(object: I): UploadArtifactRequest {
    const message = createBaseUploadArtifactRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ArtifactMetadata.fromPartial(object.metadata)
      : undefined;
    message.chunk = object.chunk ?? undefined;
    return message;
  },
};

function createBaseArtifactMetadata(): ArtifactMetadata {
  return { buildId: "", name: "", contentType: "", metadata: {} };
}

export const ArtifactMetadata = {
  encode(message: ArtifactMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.buildId !== "") {
      writer.uint32(10).string(message.buildId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ArtifactMetadata_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = ArtifactMetadata_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactMetadata {
    return {
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ArtifactMetadata): unknown {
    const obj: any = {};
    if (message.buildId !== "") {
      obj.buildId = message.buildId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactMetadata>, I>>(base?: I): ArtifactMetadata {
    return ArtifactMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactMetadata>, I>>(object: I): ArtifactMetadata {
    const message = createBaseArtifactMetadata();
    message.buildId = object.buildId ?? "";
    message.name = object.name ?? "";
    message.contentType = object.contentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseArtifactMetadata_MetadataEntry(): ArtifactMetadata_MetadataEntry {
  return { key: "", value: "" };
}

export const ArtifactMetadata_MetadataEntry = {
  encode(message: ArtifactMetadata_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArtifactMetadata_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactMetadata_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactMetadata_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ArtifactMetadata_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactMetadata_MetadataEntry>, I>>(base?: I): ArtifactMetadata_MetadataEntry {
    return ArtifactMetadata_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactMetadata_MetadataEntry>, I>>(
    object: I,
  ): ArtifactMetadata_MetadataEntry {
    const message = createBaseArtifactMetadata_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDownloadArtifactRequest(): DownloadArtifactRequest {
  return { id: "" };
}

export const DownloadArtifactRequest = {
  encode(message: DownloadArtifactRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DownloadArtifactRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadArtifactRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadArtifactRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DownloadArtifactRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadArtifactRequest>, I>>(base?: I): DownloadArtifactRequest {
    return DownloadArtifactRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadArtifactRequest>, I>>(object: I): DownloadArtifactRequest {
    const message = createBaseDownloadArtifactRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDownloadArtifactResponse(): DownloadArtifactResponse {
  return { chunk: Buffer.alloc(0) };
}

export const DownloadArtifactResponse = {
  encode(message: DownloadArtifactResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chunk.length !== 0) {
      writer.uint32(10).bytes(message.chunk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DownloadArtifactResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadArtifactResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadArtifactResponse {
    return { chunk: isSet(object.chunk) ? Buffer.from(bytesFromBase64(object.chunk)) : Buffer.alloc(0) };
  },

  toJSON(message: DownloadArtifactResponse): unknown {
    const obj: any = {};
    if (message.chunk.length !== 0) {
      obj.chunk = base64FromBytes(message.chunk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadArtifactResponse>, I>>(base?: I): DownloadArtifactResponse {
    return DownloadArtifactResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadArtifactResponse>, I>>(object: I): DownloadArtifactResponse {
    const message = createBaseDownloadArtifactResponse();
    message.chunk = object.chunk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseListArtifactsRequest(): ListArtifactsRequest {
  return { buildId: "" };
}

export const ListArtifactsRequest = {
  encode(message: ListArtifactsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.buildId !== "") {
      writer.uint32(10).string(message.buildId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactsRequest {
    return { buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "" };
  },

  toJSON(message: ListArtifactsRequest): unknown {
    const obj: any = {};
    if (message.buildId !== "") {
      obj.buildId = message.buildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListArtifactsRequest>, I>>(base?: I): ListArtifactsRequest {
    return ListArtifactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListArtifactsRequest>, I>>(object: I): ListArtifactsRequest {
    const message = createBaseListArtifactsRequest();
    message.buildId = object.buildId ?? "";
    return message;
  },
};

function createBaseListArtifactsResponse(): ListArtifactsResponse {
  return { items: [] };
}

export const ListArtifactsResponse = {
  encode(message: ListArtifactsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Artifact.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactsResponse {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Artifact.fromJSON(e)) : [] };
  },

  toJSON(message: ListArtifactsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Artifact.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListArtifactsResponse>, I>>(base?: I): ListArtifactsResponse {
    return ListArtifactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListArtifactsResponse>, I>>(object: I): ListArtifactsResponse {
    const message = createBaseListArtifactsResponse();
    message.items = object.items?.map((e) => Artifact.fromPartial(e)) || [];
    return message;
  },
};

export type EngineServiceService = typeof EngineServiceService;
export const EngineServiceService = {
  /** Pipeline operations */
  createPipeline: {
    path: "/lightci.EngineService/CreatePipeline",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePipelineRequest) => Buffer.from(CreatePipelineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePipelineRequest.decode(value),
    responseSerialize: (value: Pipeline) => Buffer.from(Pipeline.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Pipeline.decode(value),
  },
  getPipeline: {
    path: "/lightci.EngineService/GetPipeline",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPipelineRequest) => Buffer.from(GetPipelineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPipelineRequest.decode(value),
    responseSerialize: (value: Pipeline) => Buffer.from(Pipeline.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Pipeline.decode(value),
  },
  updatePipeline: {
    path: "/lightci.EngineService/UpdatePipeline",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePipelineRequest) => Buffer.from(UpdatePipelineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdatePipelineRequest.decode(value),
    responseSerialize: (value: Pipeline) => Buffer.from(Pipeline.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Pipeline.decode(value),
  },
  deletePipeline: {
    path: "/lightci.EngineService/DeletePipeline",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePipelineRequest) => Buffer.from(DeletePipelineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeletePipelineRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  listPipelines: {
    path: "/lightci.EngineService/ListPipelines",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPipelinesRequest) => Buffer.from(ListPipelinesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListPipelinesRequest.decode(value),
    responseSerialize: (value: ListPipelinesResponse) => Buffer.from(ListPipelinesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListPipelinesResponse.decode(value),
  },
  /** Build operations */
  triggerBuild: {
    path: "/lightci.EngineService/TriggerBuild",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TriggerBuildRequest) => Buffer.from(TriggerBuildRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TriggerBuildRequest.decode(value),
    responseSerialize: (value: Build) => Buffer.from(Build.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Build.decode(value),
  },
  getBuild: {
    path: "/lightci.EngineService/GetBuild",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBuildRequest) => Buffer.from(GetBuildRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBuildRequest.decode(value),
    responseSerialize: (value: Build) => Buffer.from(Build.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Build.decode(value),
  },
  cancelBuild: {
    path: "/lightci.EngineService/CancelBuild",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelBuildRequest) => Buffer.from(CancelBuildRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelBuildRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  listBuilds: {
    path: "/lightci.EngineService/ListBuilds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBuildsRequest) => Buffer.from(ListBuildsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListBuildsRequest.decode(value),
    responseSerialize: (value: ListBuildsResponse) => Buffer.from(ListBuildsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListBuildsResponse.decode(value),
  },
  getBuildLogs: {
    path: "/lightci.EngineService/GetBuildLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBuildLogsRequest) => Buffer.from(GetBuildLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBuildLogsRequest.decode(value),
    responseSerialize: (value: BuildLogs) => Buffer.from(BuildLogs.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BuildLogs.decode(value),
  },
  /** Artifact operations */
  uploadArtifact: {
    path: "/lightci.EngineService/UploadArtifact",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: UploadArtifactRequest) => Buffer.from(UploadArtifactRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UploadArtifactRequest.decode(value),
    responseSerialize: (value: Artifact) => Buffer.from(Artifact.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Artifact.decode(value),
  },
  downloadArtifact: {
    path: "/lightci.EngineService/DownloadArtifact",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: DownloadArtifactRequest) => Buffer.from(DownloadArtifactRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DownloadArtifactRequest.decode(value),
    responseSerialize: (value: DownloadArtifactResponse) =>
      Buffer.from(DownloadArtifactResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DownloadArtifactResponse.decode(value),
  },
  listArtifacts: {
    path: "/lightci.EngineService/ListArtifacts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListArtifactsRequest) => Buffer.from(ListArtifactsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListArtifactsRequest.decode(value),
    responseSerialize: (value: ListArtifactsResponse) => Buffer.from(ListArtifactsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListArtifactsResponse.decode(value),
  },
} as const;

export interface EngineServiceServer extends UntypedServiceImplementation {
  /** Pipeline operations */
  createPipeline: handleUnaryCall<CreatePipelineRequest, Pipeline>;
  getPipeline: handleUnaryCall<GetPipelineRequest, Pipeline>;
  updatePipeline: handleUnaryCall<UpdatePipelineRequest, Pipeline>;
  deletePipeline: handleUnaryCall<DeletePipelineRequest, Empty>;
  listPipelines: handleUnaryCall<ListPipelinesRequest, ListPipelinesResponse>;
  /** Build operations */
  triggerBuild: handleUnaryCall<TriggerBuildRequest, Build>;
  getBuild: handleUnaryCall<GetBuildRequest, Build>;
  cancelBuild: handleUnaryCall<CancelBuildRequest, Empty>;
  listBuilds: handleUnaryCall<ListBuildsRequest, ListBuildsResponse>;
  getBuildLogs: handleUnaryCall<GetBuildLogsRequest, BuildLogs>;
  /** Artifact operations */
  uploadArtifact: handleClientStreamingCall<UploadArtifactRequest, Artifact>;
  downloadArtifact: handleServerStreamingCall<DownloadArtifactRequest, DownloadArtifactResponse>;
  listArtifacts: handleUnaryCall<ListArtifactsRequest, ListArtifactsResponse>;
}

export interface EngineServiceClient extends Client {
  /** Pipeline operations */
  createPipeline(
    request: CreatePipelineRequest,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  createPipeline(
    request: CreatePipelineRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  createPipeline(
    request: CreatePipelineRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  getPipeline(
    request: GetPipelineRequest,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  getPipeline(
    request: GetPipelineRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  getPipeline(
    request: GetPipelineRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  updatePipeline(
    request: UpdatePipelineRequest,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  updatePipeline(
    request: UpdatePipelineRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  updatePipeline(
    request: UpdatePipelineRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Pipeline) => void,
  ): ClientUnaryCall;
  deletePipeline(
    request: DeletePipelineRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deletePipeline(
    request: DeletePipelineRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deletePipeline(
    request: DeletePipelineRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  listPipelines(
    request: ListPipelinesRequest,
    callback: (error: ServiceError | null, response: ListPipelinesResponse) => void,
  ): ClientUnaryCall;
  listPipelines(
    request: ListPipelinesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPipelinesResponse) => void,
  ): ClientUnaryCall;
  listPipelines(
    request: ListPipelinesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPipelinesResponse) => void,
  ): ClientUnaryCall;
  /** Build operations */
  triggerBuild(
    request: TriggerBuildRequest,
    callback: (error: ServiceError | null, response: Build) => void,
  ): ClientUnaryCall;
  triggerBuild(
    request: TriggerBuildRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Build) => void,
  ): ClientUnaryCall;
  triggerBuild(
    request: TriggerBuildRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Build) => void,
  ): ClientUnaryCall;
  getBuild(request: GetBuildRequest, callback: (error: ServiceError | null, response: Build) => void): ClientUnaryCall;
  getBuild(
    request: GetBuildRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Build) => void,
  ): ClientUnaryCall;
  getBuild(
    request: GetBuildRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Build) => void,
  ): ClientUnaryCall;
  cancelBuild(
    request: CancelBuildRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  cancelBuild(
    request: CancelBuildRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  cancelBuild(
    request: CancelBuildRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  listBuilds(
    request: ListBuildsRequest,
    callback: (error: ServiceError | null, response: ListBuildsResponse) => void,
  ): ClientUnaryCall;
  listBuilds(
    request: ListBuildsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListBuildsResponse) => void,
  ): ClientUnaryCall;
  listBuilds(
    request: ListBuildsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListBuildsResponse) => void,
  ): ClientUnaryCall;
  getBuildLogs(
    request: GetBuildLogsRequest,
    callback: (error: ServiceError | null, response: BuildLogs) => void,
  ): ClientUnaryCall;
  getBuildLogs(
    request: GetBuildLogsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BuildLogs) => void,
  ): ClientUnaryCall;
  getBuildLogs(
    request: GetBuildLogsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BuildLogs) => void,
  ): ClientUnaryCall;
  /** Artifact operations */
  uploadArtifact(
    callback: (error: ServiceError | null, response: Artifact) => void,
  ): ClientWritableStream<UploadArtifactRequest>;
  uploadArtifact(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Artifact) => void,
  ): ClientWritableStream<UploadArtifactRequest>;
  uploadArtifact(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Artifact) => void,
  ): ClientWritableStream<UploadArtifactRequest>;
  uploadArtifact(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Artifact) => void,
  ): ClientWritableStream<UploadArtifactRequest>;
  downloadArtifact(
    request: DownloadArtifactRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<DownloadArtifactResponse>;
  downloadArtifact(
    request: DownloadArtifactRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<DownloadArtifactResponse>;
  listArtifacts(
    request: ListArtifactsRequest,
    callback: (error: ServiceError | null, response: ListArtifactsResponse) => void,
  ): ClientUnaryCall;
  listArtifacts(
    request: ListArtifactsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListArtifactsResponse) => void,
  ): ClientUnaryCall;
  listArtifacts(
    request: ListArtifactsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListArtifactsResponse) => void,
  ): ClientUnaryCall;
}

export const EngineServiceClient = makeGenericClientConstructor(
  EngineServiceService,
  "lightci.EngineService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): EngineServiceClient;
  service: typeof EngineServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
